
var Q = require("qq");

function maxTasks(n, tasks) {
    var resources = Q.Queue();
    for (var i = 0; i < n; i++)
        resources.put();
    return tasks.map(function (task) {
        return withResource(task, resources);
    });
}

function withResource(task, resources) {
    return function () {
        // this waits for a resource, then traps any exception thrown.
        return Q.when(resources.get(), task)
        // and releases the resources regardless of the resolution
        .fin(resources.put)
    };
}

function parallel(tasks) {
   var done = Q.ref();
   return Q.all(tasks.map(function (task) {
       return task();
   }));
   return done;
}

function processSequentially() {
   console.log("started queue");
    var tasks = [
       ["1", 2],
       ["2", 4],
       ["3", 3],
       ["4", 9],
       ["5", 2]
   ].map(function(event) {
       return function () {
           return doWork(event);
       };
   });
   return parallel(maxTasks(3, tasks)).then(function () {
       console.log("finished queue");
   });
}

var working = [];
var doWork = function (event) {
    working.push(event);
    console.log("started", event[0], 'in progress:', working);
    return Q.delay(event[1] * 1000).then(function () {
        var pos = working.indexOf(event);
        working.splice(pos, 1);
        console.log("finished", event[0], 'in progress:', working);
    });
}

processSequentially()
.end();

